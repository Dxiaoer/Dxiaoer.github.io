{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"README","slug":"README","date":"2020-07-09T09:38:32.737Z","updated":"2020-07-09T09:37:04.744Z","comments":true,"path":"2020/07/09/README/","link":"","permalink":"http://yoursite.com/2020/07/09/README/","excerpt":"","text":"This README is just a fast quick start document. You can find more detailed documentation at redis.io. What is Redis?Redis is often referred as a data structures server. What this means is that Redis provides access to mutable data structures via a set of commands, which are sent using a server-client model with TCP sockets and a simple protocol. So different processes can query and modify the same data structures in a shared way. Data structures implemented into Redis have a few special properties: Redis cares to store them on disk, even if they are always served and modified into the server memory. This means that Redis is fast, but that is also non-volatile. Implementation of data structures stress on memory efficiency, so data structures inside Redis will likely use less memory compared to the same data structure modeled using an high level programming language. Redis offers a number of features that are natural to find in a database, like replication, tunable levels of durability, cluster, high availability. Another good example is to think of Redis as a more complex version of memcached, where the operations are not just SETs and GETs, but operations to work with complex data types like Lists, Sets, ordered data structures, and so forth. If you want to know more, this is a list of selected starting points: Introduction to Redis data types. http://redis.io/topics/data-types-intro Try Redis directly inside your browser. http://try.redis.io The full list of Redis commands. http://redis.io/commands There is much more inside the Redis official documentation. http://redis.io/documentation Building RedisRedis can be compiled and used on Linux, OSX, OpenBSD, NetBSD, FreeBSD.We support big endian and little endian architectures, and both 32 bitand 64 bit systems. It may compile on Solaris derived systems (for instance SmartOS) but oursupport for this platform is best effort and Redis is not guaranteed towork as well as in Linux, OSX, and *BSD there. It is as simple as: % makeYou can run a 32 bit Redis binary using: % make 32bitAfter building Redis, it is a good idea to test it using: % make testFixing build problems with dependencies or cached build optionsRedis has some dependencies which are included into the deps directory.make does not automatically rebuild dependencies even if something inthe source code of dependencies changes. When you update the source code with git pull or when code inside thedependencies tree is modified in any other way, make sure to use the followingcommand in order to really clean everything and rebuild from scratch: make distcleanThis will clean: jemalloc, lua, hiredis, linenoise. Also if you force certain build options like 32bit target, no C compileroptimizations (for debugging purposes), and other similar build time options,those options are cached indefinitely until you issue a make distcleancommand. Fixing problems building 32 bit binariesIf after building Redis with a 32 bit target you need to rebuild itwith a 64 bit target, or the other way around, you need to perform amake distclean in the root directory of the Redis distribution. In case of build errors when trying to build a 32 bit binary of Redis, trythe following steps: Install the packages libc6-dev-i386 (also try g++-multilib). Try using the following command line instead of make 32bit:make CFLAGS=&quot;-m32 -march=native&quot; LDFLAGS=&quot;-m32&quot; AllocatorSelecting a non-default memory allocator when building Redis is done by settingthe MALLOC environment variable. Redis is compiled and linked against libcmalloc by default, with the exception of jemalloc being the default on Linuxsystems. This default was picked because jemalloc has proven to have fewerfragmentation problems than libc malloc. To force compiling against libc malloc, use: % make MALLOC=libcTo compile against jemalloc on Mac OS X systems, use: % make MALLOC=jemallocVerbose buildRedis will build with a user friendly colorized output by default.If you want to see a more verbose output use the following: % make V=1Running RedisTo run Redis with the default configuration just type: % cd src % ./redis-serverIf you want to provide your redis.conf, you have to run it using an additionalparameter (the path of the configuration file): % cd src % ./redis-server /path/to/redis.confIt is possible to alter the Redis configuration by passing parameters directlyas options using the command line. Examples: % ./redis-server --port 9999 --slaveof 127.0.0.1 6379 % ./redis-server /etc/redis/6379.conf --loglevel debugAll the options in redis.conf are also supported as options using the commandline, with exactly the same name. Playing with RedisYou can use redis-cli to play with Redis. Start a redis-server instance,then in another terminal try the following: % cd src % ./redis-cli redis&gt; ping PONG redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; redis&gt; incr mycounter (integer) 1 redis&gt; incr mycounter (integer) 2 redis&gt;You can find the list of all the available commands at http://redis.io/commands. Installing RedisIn order to install Redis binaries into /usr/local/bin just use: % make installYou can use make PREFIX=/some/other/directory install if you wish to use adifferent destination. Make install will just install binaries in your system, but will not configureinit scripts and configuration files in the appropriate place. This is notneeded if you want just to play a bit with Redis, but if you are installingit the proper way for a production system, we have a script doing thisfor Ubuntu and Debian systems: % cd utils % ./install_server.shThe script will ask you a few questions and will setup everything you needto run Redis properly as a background daemon that will start again onsystem reboots. You’ll be able to stop and start Redis using the script named/etc/init.d/redis_&lt;portnumber&gt;, for instance /etc/init.d/redis_6379. Code contributionsNote: by contributing code to the Redis project in any form, including sendinga pull request via Github, a code fragment or patch via private email orpublic discussion groups, you agree to release your code under the termsof the BSD license that you can find in the COPYING file included in the Redissource distribution. Please see the CONTRIBUTING file in this source distribution for moreinformation. Redis internalsIf you are reading this README you are likely in front of a Github pageor you just untarred the Redis distribution tar ball. In both the casesyou are basically one step away from the source code, so here we explainthe Redis source code layout, what is in each file as a general idea, themost important functions and structures inside the Redis server and so forth.We keep all the discussion at a high level without digging into the detailssince this document would be huge otherwise and our code base changescontinuously, but a general idea should be a good starting point tounderstand more. Moreover most of the code is heavily commented and easyto follow. Source code layoutThe Redis root directory just contains this README, the Makefile whichcalls the real Makefile inside the src directory and an exampleconfiguration for Redis and Sentinel. You can find a few shellscripts that are used in order to execute the Redis, Redis Cluster andRedis Sentinel unit tests, which are implemented inside the testsdirectory. Inside the root are the following important directories: src: contains the Redis implementation, written in C. tests: contains the unit tests, implemented in Tcl. deps: contains libraries Redis uses. Everything needed to compile Redis is inside this directory; your system just needs to provide libc, a POSIX compatible interface and a C compiler. Notably deps contains a copy of jemalloc, which is the default allocator of Redis under Linux. Note that under deps there are also things which started with the Redis project, but for which the main repository is not anitrez/redis. An exception to this rule is deps/geohash-int which is the low level geocoding library used by Redis: it originated from a different project, but at this point it diverged so much that it is developed as a separated entity directly inside the Redis repository. There are a few more directories but they are not very important for our goalshere. We’ll focus mostly on src, where the Redis implementation is contained,exploring what there is inside each file. The order in which files areexposed is the logical one to follow in order to disclose different layersof complexity incrementally. Note: lately Redis was refactored quite a bit. Function names and filenames have been changed, so you may find that this documentation reflects theunstable branch more closely. For instance in Redis 3.0 the server.cand server.h files were named to redis.c and redis.h. However the overallstructure is the same. Keep in mind that all the new developments and pullrequests should be performed against the unstable branch. server.hThe simplest way to understand how a program works is to understand thedata structures it uses. So we’ll start from the main header file ofRedis, which is server.h. All the server configuration and in general all the shared state isdefined in a global structure called server, of type struct redisServer.A few important fields in this structure are: server.db is an array of Redis databases, where data is stored. server.commands is the command table. server.clients is a linked list of clients connected to the server. server.master is a special client, the master, if the instance is a slave. There are tons of other fields. Most fields are commented directly insidethe structure definition. Another important Redis data structure is the one defining a client.In the past it was called redisClient, now just client. The structurehas many fields, here we’ll just show the main ones: struct client { int fd; sds querybuf; int argc; robj **argv; redisDb *db; int flags; list *reply; char buf[PROTO_REPLY_CHUNK_BYTES]; ... many other fields ... }The client structure defines a connected client: The fd field is the client socket file descriptor. argc and argv are populated with the command the client is executing, so that functions implementing a given Redis command can read the arguments. querybuf accumulates the requests from the client, which are parsed by the Redis server according to the Redis protocol and executed by calling the implementations of the commands the client is executing. reply and buf are dynamic and static buffers that accumulate the replies the server sends to the client. These buffers are incrementally written to the socket as soon as the file descriptor is writable. As you can see in the client structure above, arguments in a commandare described as robj structures. The following is the full robjstructure, which defines a Redis object: typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */ int refcount; void *ptr; } robj;Basically this structure can represent all the basic Redis data types likestrings, lists, sets, sorted sets and so forth. The interesting thing is thatit has a type field, so that it is possible to know what type a givenobject has, and a refcount, so that the same object can be referencedin multiple places without allocating it multiple times. Finally the ptrfield points to the actual representation of the object, which might varyeven for the same type, depending on the encoding used. Redis objects are used extensively in the Redis internals, however in orderto avoid the overhead of indirect accesses, recently in many placeswe just use plain dynamic strings not wrapped inside a Redis object. server.cThis is the entry point of the Redis server, where the main() functionis defined. The following are the most important steps in order to startupthe Redis server. initServerConfig() setups the default values of the server structure. initServer() allocates the data structures needed to operate, setup the listening socket, and so forth. aeMain() starts the event loop which listens for new connections. There are two special functions called periodically by the event loop: serverCron() is called periodically (according to server.hz frequency), and performs tasks that must be performed from time to time, like checking for timedout clients. beforeSleep() is called every time the event loop fired, Redis served a few requests, and is returning back into the event loop. Inside server.c you can find code that handles other vital things of the Redis server: call() is used in order to call a given command in the context of a given client. activeExpireCycle() handles eviciton of keys with a time to live set via the EXPIRE command. freeMemoryIfNeeded() is called when a new write command should be performed but Redis is out of memory according to the maxmemory directive. The global variable redisCommandTable defines all the Redis commands, specifying the name of the command, the function implementing the command, the number of arguments required, and other properties of each command. networking.cThis file defines all the I/O functions with clients, masters and slaves(which in Redis are just special clients): createClient() allocates and initializes a new client. the addReply*() family of functions are used by commands implementations in order to append data to the client structure, that will be transmitted to the client as a reply for a given command executed. writeToClient() transmits the data pending in the output buffers to the client and is called by the writable event handler sendReplyToClient(). readQueryFromClient() is the readable event handler and accumulates data from read from the client into the query buffer. processInputBuffer() is the entry point in order to parse the client query buffer according to the Redis protocol. Once commands are ready to be processed, it calls processCommand() which is defined inside server.c in order to actually execute the command. freeClient() deallocates, disconnects and removes a client. aof.c and rdb.cAs you can guess from the names these files implement the RDB and AOFpersistence for Redis. Redis uses a persistence model based on the fork()system call in order to create a thread with the same (shared) memorycontent of the main Redis thread. This secondary thread dumps the contentof the memory on disk. This is used by rdb.c to create the snapshotson disk and by aof.c in order to perform the AOF rewrite when theappend only file gets too big. The implementation inside aof.c has additional functions in order toimplement an API that allows commands to append new commands into the AOFfile as clients execute them. The call() function defined inside server.c is responsible to callthe functions that in turn will write the commands into the AOF. db.cCertain Redis commands operate on specific data types, others are general.Examples of generic commands are DEL and EXPIRE. They operate on keysand not on their values specifically. All those generic commands aredefined inside db.c. Moreover db.c implements an API in order to perform certain operationson the Redis dataset without directly accessing the internal data structures. The most important functions inside db.c which are used in many commandsimplementations are the following: lookupKeyRead() and lookupKeyWrite() are used in order to get a pointer to the value associated to a given key, or NULL if the key does not exist. dbAdd() and its higher level counterpart setKey() create a new key in a Redis database. dbDelete() removes a key and its associated value. emptyDb() removes an entire single database or all the databases defined. The rest of the file implements the generic commands exposed to the client. object.cThe robj structure defining Redis objects was already described. Insideobject.c there are all the functions that operate with Redis objects ata basic level, like functions to allocate new objects, handle the referencecounting and so forth. Notable functions inside this file: incrRefcount() and decrRefCount() are used in order to increment or decrement an object reference count. When it drops to 0 the object is finally freed. createObject() allocates a new object. There are also specialized functions to allocate string objects having a specific content, like createStringObjectFromLongLong() and similar functions. This file also implements the OBJECT command. replication.cThis is one of the most complex files inside Redis, it is recommended toapproach it only after getting a bit familiar with the rest of the code base.In this file there is the implementation of both the master and slave roleof Redis. One of the most important functions inside this file is replicationFeedSlaves() that writes commands to the clients representing slave instances connectedto our master, so that the slaves can get the writes performed by the clients:this way their data set will remain synchronized with the one in the master. This file also implements both the SYNC and PSYNC commands that areused in order to perform the first synchronization between masters andslaves, or to continue the replication after a disconnection. Other C files t_hash.c, t_list.c, t_set.c, t_string.c and t_zset.c contains the implementation of the Redis data types. They implement both an API to access a given data type, and the client commands implementations for these data types. ae.c implements the Redis event loop, it’s a self contained library which is simple to read and understand. sds.c is the Redis string library, check http://github.com/antirez/sds for more information. anet.c is a library to use POSIX networking in a simpler way compared to the raw interface exposed by the kernel. dict.c is an implementation of a non-blocking hash table which rehashes incrementally. scripting.c implements Lua scripting. It is completely self contained from the rest of the Redis implementation and is simple enough to understand if you are familar with the Lua API. cluster.c implements the Redis Cluster. Probably a good read only after being very familiar with the rest of the Redis code base. If you want to read cluster.c make sure to read the Redis Cluster specification. Anatomy of a Redis commandAll the Redis commands are defined in the following way: void foobarCommand(client *c) { printf(&quot;%s&quot;,c-&gt;argv[1]-&gt;ptr); /* Do something with the argument. */ addReply(c,shared.ok); /* Reply something to the client. */ }The command is then referenced inside server.c in the command table: {&quot;foobar&quot;,foobarCommand,2,&quot;rtF&quot;,0,NULL,0,0,0,0,0},In the above example 2 is the number of arguments the command takes,while &quot;rtF&quot; are the command flags, as documented in the command tabletop comment inside server.c. After the command operates in some way, it returns a reply to the client,usually using addReply() or a similar function defined inside networking.c. There are tons of commands implementations inside th Redis source codethat can serve as examples of actual commands implementations. To writea few toy commands can be a good exercise to familiarize with the code base. There are also many other files not described here, but it is useless tocover everything. We want to just help you with the first steps.Eventually you’ll find your way inside the Redis code base :-) Enjoy!","categories":[],"tags":[]},{"title":"my-first-blog","slug":"my-first-blog","date":"2020-07-09T08:55:18.000Z","updated":"2020-07-09T08:57:18.228Z","comments":true,"path":"2020/07/09/my-first-blog/","link":"","permalink":"http://yoursite.com/2020/07/09/my-first-blog/","excerpt":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；","text":"前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等；","categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"http://yoursite.com/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"http://yoursite.com/tags/tag2/"},{"name":"tag3","slug":"tag3","permalink":"http://yoursite.com/tags/tag3/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-09T06:42:36.081Z","updated":"2020-07-09T06:42:36.081Z","comments":true,"path":"2020/07/09/hello-world/","link":"","permalink":"http://yoursite.com/2020/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"http://yoursite.com/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"http://yoursite.com/tags/tag2/"},{"name":"tag3","slug":"tag3","permalink":"http://yoursite.com/tags/tag3/"}]}